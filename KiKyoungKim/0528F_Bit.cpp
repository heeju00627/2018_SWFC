#include <iostream>
using namespace std;

int X, K;

bool bit[32];
long long int  pow2[64] = { 1, 2 , 4 , 8 , 16 , 32 , 64 , 128 , 256 , 512 ,
				1024 , 2048 , 4096 , 8192 , 16384 , 32768 , 65536 ,
				131072 , 262144 , 524288 , 1048576 , 2097152 , 4194304 , 
				8388608 , 16777216 , 33554432 , 67108864 , 134217728 , 
				268435456 , 536870912 , 1073741824, 2147483648 , 4294967296 , 
				8589934592 , 17179869184 , 34359738368 , 68719476736 , 137438953472 ,
				274877906944 , 549755813888 , 1099511627776 , 2199023255552 , 4398046511104 ,
				8796093022208 , 17592186044416 , 35184372088832 , 70368744177664 ,
				140737488355328 , 281474976710656 , 562949953421312 , 1125899906842624 , 
				2251799813685248 , 4503599627370496 , 9007199254740992 , 18014398509481984 ,
				36028797018963968 , 72057594037927936 , 144115188075855872 ,
				288230376151711744 , 576460752303423488 , 1152921504606846976 , 
				2305843009213693952 , 4611686018427387904 , 0 };
//power of 2 

bool Xb[64]; // bit code of X
bool Kb[64]; // bit code of K
bool Nb[64]; // bit code of extended

long long int res;

/*
x + y = x | y 가 성립하려면
x의 0이 있는 부분만 y는 값을 가질 수 있다.
그래서 x를 2진수로 변환했을 때, 0인 부분들만 모아 값을 주는 것이 가능한 y의 값들.
예를 들어 x가 10인 경우, 2진수로 1010 이 된다.
이 때 x+y=x|y를 만족하는 가능한 y는
00001, 00100, 00101, 10000, 10001, ... 이다.
여기서 x가 1인 부분만 제외하고 보면
0 0 1, 0 1 0, 0 1 1, 1 0 0, 1 0 1, ... 이다.
이를 통해 K번째를 찾을 수 있다.
만약 K가 3이라면, 0 1 1이고, 이 2진수를 x가 1인 자리를 제외하여 분배하면
0 1 1
01010
가 된다. 저기서 공백을 다시 0으로 채우면, 00101 이 되고 이 값느 5가 된다.
x가 10인 경우, 위 공식을 만족하는 자연수의 K(3)번째는 5가 되는 셈이다.

이에 착안하여 주어진 x,k를 2진수로 변환한 후
k의 2진 코드를 x의 0 부분에 맞도록 퍼뜨린 후
그 퍼진 2진 코드를 10진수로 변환하면 답이 된다.

여기서 주어진 값의 범위는 32bit지만, 답은 그 2배인 64bit까지 가능하므로
long long int 및 64bit로 설정했다. */


void dec2bin(int d, bool *b)
{
	for (int i = 31; i >= 0; i--)
	{
		if (d >= pow2[i])
		{
			d -= pow2[i];
			b[i] = 1;
		}
	}
}
void spread()
{
	int pt = 0;
	for (int i = 0; i < 64; i++)
	{
		if (Xb[i] == 0)
		{
			Nb[i] = Kb[pt++];
		}
	}
}
void bin2dec()
{
	res = 0;
	for (int i = 0; i < 64; i++)
	{
		if (Nb[i])
			res += pow2[i];
	}
}

int main(void)
{
	cin >> X >> K;
	dec2bin(X, Xb);
	dec2bin(K, Kb);
	spread();
	bin2dec();

	cout << res << endl;


	return 0;
}